## Ensemble Programming: Lessons Learned from Mob Programming
If you’ve ever thought about mob programming and pictured a chaotic horde shouting over each other while one person types frantically, you’re only partly right. But don’t let the name fool you—mob programming (or ensemble programming, if you want to sound fancy) is structured, collaborative, and surprisingly effective.

It’s not just about writing better code (though it does that); it’s about building a team environment where everyone learns, contributes, and grows. Let me walk you through what I’ve learned about mobbing—from fumbling through my first session to embracing the power of collective problem-solving.
### What Is Mob Programming?
Mob programming is essentially pair programming, but with the whole team. Imagine this:
* **The Driver**: One person types (no side quests, no shortcuts).
* **The Steerers**: Everyone else reviews, discusses, and provides input.
* **Frequent Rotation**: Every 10–15 minutes, roles switch to keep the energy fresh.

Think of it like a football team (or chess club, if that’s more your speed). Everyone has a role, and success comes from strategy, communication, and trust.
### How I Got Started: Bootcamp Beginnings
My first taste of mob programming came during a bootcamp at Co-op. A facilitator introduced us to the concept, and while I was initially sceptical, it quickly became clear this wasn’t just organised chaos.

We learned step by step:
1. **Timers**: To rotate the Driver regularly.
2. **Roles**: Inspired by frameworks like the Pomodoro technique and extreme programming roles, we embraced responsibilities like note-taking, timekeeping, and even devil’s advocate.
3. **Red-Green-Refactor in 2 Minutes**: We used Test-Driven Development (TDD), aiming to write failing tests, pass them, and refactor them in quick iterations. If it took longer than two minutes, we reevaluated.

### The Tools That Made a Difference
Mob programming is only as good as the tools you use. Here’s what worked for us:
* **Timers**: Essential for keeping everyone engaged and ensuring the Driver role rotates smoothly. A classic Pomodoro timer works wonders.
* **[mob.sh](https://mob.sh/)**: This nifty tool is a lifesaver for remote sessions. It ensures seamless collaboration, so we spend more time coding and less time troubleshooting screen sharing.
* **[Around](https://www.around.co/) (Smaller Video Feeds)**: If you’re remote, small, unobtrusive video feeds reduce distractions while keeping faces visible for non-verbal communication.
* **Real-Time Code Reviews**: With everyone looking at the same screen, code reviews happen *as you code*. No more “I’ll review this later” excuses.

### Why Try Mob Programming?
1. **Better Code Quality**

When everyone’s focused on the same task, you catch bugs early, write cleaner code, and solve problems more creatively. It’s peer programming on steroids.

2. **Accelerated Learning**

Mob programming is a crash course in shared knowledge. You’ll learn from seniors, juniors, and peers alike—picking up everything from coding techniques to quirky keyboard shortcuts.

3. **Improved Team Dynamics**

Coding as a team builds trust and camaraderie. You’ll get to know how your colleagues think and communicate, which makes collaborating outside mobbing sessions easier too.

4. **Distributed Knowledge**

No more silos. Everyone gets involved in the code, which makes onboarding new team members a breeze and ensures no single person becomes a bottleneck.
### Pro Tips for Smooth Mob Programming
1. **Define Roles Clearly**

Go beyond Driver and Steerer. Borrow ideas from frameworks like [Cucumber’s Five Roles](https://cucumber.io/blog/bdd/five-roles-in-a-healthy-mob/) or [Extreme Programming Roles](https://wiki.c2.com/?ExtremeRoles). Consider adding:
* **The Timekeeper**: Manages the timer and rotation schedule.
* **The Researcher**: Looks up solutions or libraries mid-session.
* **The Devil’s Advocate**: Challenges assumptions and keeps discussions balanced.

2. **Embrace TDD (Red-Green-Refactor)**

Test-driven development is a natural fit for mob programming. Write a failing test (red), pass it (green), and refactor in short bursts. If progress stalls after two minutes, step back and rethink.

3. **Take Breaks**

Pomodoro-style breaks (e.g., 25 minutes of work, 5 minutes of rest) keep energy levels high and prevent burnout. Plus, they’re a great time for snacks.

4. **Rotate Often**

Frequent role rotation keeps things engaging and ensures everyone shares knowledge and responsibility. No one should feel left out—or stuck driving for an hour straight.
### Reflecting on the Experience
What I love most about mob programming is how it transforms coding into a team sport. You’ll debate approaches, refine ideas, and occasionally realise your teammate’s love of 2-space indentation is not a hill worth dying on.

More importantly, you’ll grow as a team. The insights gained, trust built, and laughs shared are just as valuable as the code you produce.
### Final Thoughts: Why Not Give It a Go?
If you’ve never tried mob programming, now’s the time. Start with a small task, set a timer, and experiment. Whether you’re refining a feature or fixing a bug, you’ll be amazed at how much you learn—and how much fun you have—when you code together.

Happy mobbing!
